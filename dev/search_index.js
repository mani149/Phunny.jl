var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Building-a-lattice-model","page":"Tutorials","title":"Building a lattice model","text":"","category":"section"},{"location":"tutorials/#Using-Sunny-data","page":"Tutorials","title":"Using Sunny data","text":"","category":"section"},{"location":"tutorials/#Computing-msd","page":"Tutorials","title":"Computing msd","text":"","category":"section"},{"location":"#Phunny","page":"Home","title":"Phunny","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Phunny.","category":"page"},{"location":"#What's-Phunny?","page":"Home","title":"What's Phunny?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Nothin if u askin","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"u could be here","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Phunny\n\n","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/mani149/Phunny.jl/\n","category":"page"},{"location":"Conventions/#Crystal-Lattices","page":"Crystal Lattices","title":"Crystal Lattices","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In general, a 3-dimensional crystal is defined using a Bravais lattice.  The Bravais lattice is defined by three primitive vectors veca_1, veca_2, and veca_3.  For the 3-dimensional Bravais lattice, these three primitive vectors are used to tesselate mathbbR^3:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"  vecr = n_1veca_1 + n_2veca_2 + n_3veca_3    n_1n_2n_3 in mathbbZ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In the simplest case, an atom may be placed directly on the Bravais points vecr.  In reality, it's extremely common for atoms to be at non-Bravais points, requiring basis positions vecdelta.  Then, the atomic position vector vecrprime = vecr + vecdelta. ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The Bravais lattice has a dual which is commonly referred to as the reciprocal-space or momentum-space lattice. The primitive vectors for the reciprocal-space lattice are defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"    beginsplit\n        vecb_1 = frac2piV(vecb_2 times vecb_1)\n        vecb_2 = frac2piV(b_3timesvecb_1)\n        vecb_3 = frac2piV(vecb_1timesvecb_2)\n    endsplit","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where V = vecb_1cdot(vecb_2timesvecb_3) is the volume of the unit cell. The reciprocal-space lattice is tesselated:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"vecq = hvecb_1 + kvecb_2 + ellvecb_3","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where hkell define the \\text{Miller indices} of the wave-vector vecq.  The Miller indices define the spacing between planes in the reciprocal lattice:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"d = frac2pivecq_hkell","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The reciprocal-space vectors are translationally symmetric such that vecq = vecq + veck  for veck in vecq_m belonging to the set of reciprocal lattice points.","category":"page"},{"location":"Conventions/#Scattering-Theory","page":"Crystal Lattices","title":"Scattering Theory","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The one-phonon dynamic structure factor is the spectral function corresponding to inelastic scattering  events where the energy transfer Delta E neq 0. During the inelastic scattering, the neutron either  loses energy (creates a phonon) or gains energy (destroys a phonon). The one-phonon contribution to the  structure factor is defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"S_textph^pm(vecqomega beta) = sum_nusum_veckA_nu(vecq)Delta_nu^pm(vecqveck)left(n_nu(beta) + frac1 pm 12right)","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where A_nu(vecq) is the scattering amplitude of the nu^th phonon mode induced by the momentum transfer mathbfq. The scattering amplitude is related to the nu^th phonon mode polarization vector vecxi_nu such that A_nu(mathbfq) = (vecqcdotvecxi_nu)^2omega_nu  for single-phonon scattering events.The Bose-Einstein distribution includes the thermal dependence such that n_nu(beta) = e^-betahbaromega_nu - 1^-1 with beta = (k_bT)^-1. The selection rules for scattering are enforced by,Delta_nu^pm(vecqveck) = delta(omega pm omega_nu)delta(mathbfq -mathbfk) where delta() denotes a Dirac delta. ","category":"page"},{"location":"refs/#Reference","page":"References","title":"Reference","text":"","category":"section"},{"location":"refs/#Contents","page":"References","title":"Contents","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#Index","page":"References","title":"Index","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#Phunny.Phunny","page":"References","title":"Phunny.Phunny","text":"Extensions for making Sunny.jl usable\n\n\n\n\n\n","category":"module"},{"location":"refs/#Phunny.B_isotropic_from_phonons-Tuple{Model, Any}","page":"References","title":"Phunny.B_isotropic_from_phonons","text":"B_isotropic_from_phonons(model, Φ; T, cryst, qgrid=(12,12,12), q_cell=:primitive, eps_meV=1e-6)\n\nReturn isotropic Debye–Waller B-factors (Å²) per site from first principles: Bs(T) = 8π² ⟨us^2⟩(T).\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.assemble_force_constants!-Tuple{Model}","page":"References","title":"Phunny.assemble_force_constants!","text":"assemble_force_constants!(model)\n\nBuilds real-space force constants Φ as a dictionary of 3×3 blocks keyed by (i,j,R). Per-bond block: K = kL*(êêᵀ) + kT*(I - êêᵀ) with ê = r0/‖r0‖, applied to (uj@R - ui@0). Conservation laws are enforced later by enforce_asr!.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.build_model-Tuple{Any}","page":"References","title":"Phunny.build_model","text":"build_model(crystal; mass, neighbors_sunny=nothing, neighbors=nothing, cutoff=nothing, use_sunny_radius=true, kL=1.0, kT=1.0, supercell=(1,1,1))\n\nCreate a Model from a Sunny-like crystal object. Minimal interface expected:\n\nEither Sunny-style fields: crystal.latvecs (3×3), crystal.positions (fractional), crystal.types (Strings)\nor generic fields: crystal.lattice (3×3), crystal.positions (fractional), crystal.species (Symbols/Strings)\n\nBond assembly precedence:\n\nIf neighbors_sunny (e.g. Vector{Sunny.Bond}) is provided → fast path via Sunny geometry.\nElse if neighbors (list of tuples as documented in neighbor_bonds_from_sunny) is provided → fast tuple path.\nElse if use_sunny_radius && cutoff!=nothing && Sunny loaded → build via Sunny.all_bonds_for_atom.\nElse → fallback to portable cutoff scan neighbor_bonds_cutoff.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.dynamical_matrix-Tuple{Model, Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.dynamical_matrix","text":"dynamical_matrix(model, Φ, q_cart)\n\nMass-weighted dynamical matrix D(q) from real-space Φ blocks. q_cart is Cartesian (Å⁻¹). Returns Hermitian matrix.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.enforce_asr!-Tuple{Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, Int64}","page":"References","title":"Phunny.enforce_asr!","text":"enforce_asr!(Φ, N)\n\nAcoustic sum rule: for each atom i, ∑{j,R} Φ{i j}(R) = 0. Adjust on-site blocks to satisfy translational invariance.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.msd_from_phonons-Tuple{Model, Any}","page":"References","title":"Phunny.msd_from_phonons","text":"msd_from_phonons(model, Φ; T, cryst, qgrid=(12,12,12), q_cell=:primitive, eps_meV=1e-6)\n\nCompute per-site mean-square displacements ⟨us^2⟩(T) in Å² directly from the phonon spectrum: ⟨us^2⟩ = (1/Nq) * Σ{q,ν} (ħ² / (2 Ms EJ)) * coth(EJ / (2 kB T)) * Σα |ephys(s,α;q,ν)|² where EJ = EmeV ⋅ meVtoJ and ephys are physical (non mass-weighted) polarization vectors. Modes with E ≤ eps_meV are skipped (Γ handling); refine qgrid for convergence.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_cutoff-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}, Vector{StaticArraysCore.SVector{3, Float64}}}","page":"References","title":"Phunny.neighbor_bonds_cutoff","text":"neighbor_bonds_cutoff(lattice, fracpos; cutoff, kL, kT, supercell=(1,1,1))\n\nConstruct bonds using a radial cutoff by scanning a small supercell (portable path). kL and kT can be numbers or functions (i,j,rij)->stiffness for non-uniform springs. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_from_sunny-Tuple{Any, Any}","page":"References","title":"Phunny.neighbor_bonds_from_sunny","text":"neighbor_bonds_from_sunny(cryst, bonds; kL=1.0, kT=1.0)\n\nFast-path bond construction using Sunny's bonds and geometry. bonds may be a Vector of:\n\nSunny.Bond         (fields: i,j,n)\nTuples (i,j,n::SVector{3,Int})\nTuples (i,j,Δ::SVector{3,Float64})  # direct Cartesian Δ\n\nkL/kT can be numbers or (i,j,r0)->value. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_radius-Tuple{Any}","page":"References","title":"Phunny.neighbor_bonds_radius","text":"neighbor_bonds_radius(cryst; cutoff, kL, kT)\n\nSunny-powered radius query: builds bonds using Sunny.all_bonds_for_atom. Requires using Sunny. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.onephonon_dsf-Tuple{Model, Any, StaticArraysCore.SVector{3, Float64}, AbstractVector{<:Real}}","page":"References","title":"Phunny.onephonon_dsf","text":"onephonon_dsf(model, Φ, q, Evals; T=300.0, bcoh=nothing, B=nothing, η=0.5, mass_unit=:amu, q_basis=:cart, q_cell=:primitive, cryst=nothing)\n\nComputes one-phonon coherent S(q,E) on energy grid Evals (meV).\n\nDebye–Waller is intrinsic: full anisotropic tensors Us(T) are computed from the phonon spectrum (no ΘD).\nbcoh optional Vector of coherent scattering lengths (length N)\nη Gaussian HWHM for energy broadening (meV)\nmass_unit :amu or :kg (Model.mass is assumed to be :amu typically)\nq_basis/q_cell/cryst follow phonons conventions\n\nReturns S(E) (arbitrary but consistent units).\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.onephonon_dsf_4d-Tuple{Model, Any, Vararg{AbstractVector, 4}}","page":"References","title":"Phunny.onephonon_dsf_4d","text":"onephonon_dsf_4d(model, Φ, q1, q2, q3, Evals;\n                 q_basis=:rlu, q_cell=:primitive, cryst=nothing,\n                 T=300.0, η=0.5, mass_unit=:amu, bcoh=nothing,\n                 threads=true)\n\nCompute the one-phonon coherent dynamic structure factor on a 4D grid:\n\nq1, q2, q3 are 1D axes defining a rectilinear grid in q-space.\nIf q_basis=:rlu, they are fractional coordinates along the three reciprocal basis vectors.\nIf q_basis=:cart, they are Cartesian components (Å⁻¹).\nEvals is the 1D energy axis (meV). Result has shape (length(q1), length(q2), length(q3), length(Evals)).\n\nThis routine is thread-parallel over the q-grid.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.phonons-Tuple{Model, Any, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.phonons","text":"phonons(model, Φ, q; q_basis=:cart, q_cell=:primitive)\n\nDiagonalize D(q). Returns (E, Evec) with energies in meV and 3N×3N eigenvectors. q may be in Cartesian Å⁻¹ (q_basis=:cart) or RLU (q_basis=:rlu with q_cell=:primitive or :conventional). If passing RLU, also pass the underlying crystal cryst via keyword.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.q_cartesian-Tuple{Any, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.q_cartesian","text":"q_cartesian(cryst, q; basis=:cart, cell=:primitive)\n\nConvert a wavevector to Cartesian (Å⁻¹). q may be:\n\nbasis=:cart    → already Cartesian (Å⁻¹)\nbasis=:rlu     → reduced lattice units (h,k,l). cell chooses :primitive or :conventional.\n\nUses Sunny.prim_recipvecs(cryst) if Sunny is loaded and cell=:primitive, otherwise falls back to 2π * inv(L)' where L is the corresponding direct lattice.\n\n\n\n\n\n","category":"method"}]
}
