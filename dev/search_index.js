var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Building-a-lattice-model","page":"Tutorials","title":"Building a lattice model","text":"","category":"section"},{"location":"tutorials/#Using-Sunny-data","page":"Tutorials","title":"Using Sunny data","text":"","category":"section"},{"location":"tutorials/#Computing-msd","page":"Tutorials","title":"Computing msd","text":"","category":"section"},{"location":"#Phunny","page":"Home","title":"Phunny","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Phunny.","category":"page"},{"location":"#What's-Phunny?","page":"Home","title":"What's Phunny?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Phunny is a package for semi-classical phonon calculations, designed to integrate with the linear spin wave theory package Sunny. ","category":"page"},{"location":"#Example-Usage","page":"Home","title":"Example Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Phunny, Sunny, StaticArrays\n\n#Build crystal with Sunny\na = 5.43; L = lattice_vectors(a,a,a,90,90,90)\nfracpos = [@SVector[0.0, 0.0, 0.0],\n           @SVector[0.25, 0.25, 0.25]]\ntypes = [\"Si\", \"Si\"]\ncryst = Crystal(L, fracpos; types=types)\n\n#Build phonon model with Phunny\nmodel = build_model(cryst; cutoff=0.45a, kL=10.0, kT=0.0)\nFCMs = assemble_force_constants!(model); enforce_asr!(FCMs, model.N)\n\n#Solve eigenvalue problem at Gamma point\nq0 = @SVector[0.0, 0.0, 0.0]\neigvals, eigvecs = phonons(model, FCMs, q0; q_basis=:rlu) \n","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation is currently possible via the Julia package registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(v1.11) pkg> add https://github.com/mani149/Phunny.jl/\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"https://github.com/mani149/Phunny.jl/\")","category":"page"},{"location":"Conventions/#Crystal-Lattices","page":"Crystal Lattices","title":"Crystal Lattices","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In general, a 3-dimensional crystal is defined using a Bravais lattice.  The Bravais lattice is defined by three primitive vectors veca_1, veca_2, and veca_3.  For the 3-dimensional Bravais lattice, these three primitive vectors are used to tesselate mathbbR^3:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"  vecr = n_1veca_1 + n_2veca_2 + n_3veca_3    n_1n_2n_3 in mathbbZ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"In the simplest case, an atom may be placed directly on the Bravais points vecr.  In reality, it's extremely common for atoms to be at non-Bravais points, requiring basis positions vecdelta.  Then, the atomic position vector vecrprime = vecr + vecdelta. ","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The Bravais lattice has a dual which is commonly referred to as the reciprocal-space or momentum-space lattice. The primitive vectors for the reciprocal-space lattice are defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"    beginsplit\n        vecb_1 = frac2piV(vecb_2 times vecb_1)\n        vecb_2 = frac2piV(b_3timesvecb_1)\n        vecb_3 = frac2piV(vecb_1timesvecb_2)\n    endsplit","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where V = vecb_1cdot(vecb_2timesvecb_3) is the volume of the unit cell. The reciprocal-space lattice is tesselated:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"vecq = hvecb_1 + kvecb_2 + ellvecb_3","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where hkell define the \\text{Miller indices} of the wave-vector vecq.  The Miller indices define the spacing between planes in the reciprocal lattice:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"d = frac2pivecq_hkell","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The reciprocal-space vectors are translationally symmetric such that vecq = vecq + veck  for veck in vecq_m belonging to the set of reciprocal lattice points.","category":"page"},{"location":"Conventions/#Semi-classical-Phonons","page":"Crystal Lattices","title":"Semi-classical Phonons","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"A phonon is defined as the quanta of vibration. It is a bosonic (force carrying) excitation  between ions within a crystal lattice. The simplest way to represent phonons is using the  classical spring system as our model. By Newton's 2nd law, vecF = mddotvecu  where m is the ionic mass and vecu is a finite displacement away from the equilibrium position vecr^texteq. The interaction which causes the displacement can be modeled as a spring potential between ions U = frac12kappa vecu^2. ","category":"page"},{"location":"Conventions/#Scattering-Theory","page":"Crystal Lattices","title":"Scattering Theory","text":"","category":"section"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"The one-phonon dynamic structure factor is the spectral function corresponding to inelastic scattering  events where the energy transfer Delta E neq 0. During the inelastic scattering, the neutron either  loses energy (creates a phonon) or gains energy (destroys a phonon). The one-phonon contribution to the  structure factor is defined:","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"S_textph^pm(vecqomega beta) = sum_nusum_veckA_nu(vecq)Delta_nu^pm(vecqveck)left(n_nu(beta) + frac1 pm 12right)","category":"page"},{"location":"Conventions/","page":"Crystal Lattices","title":"Crystal Lattices","text":"where A_nu(vecq) is the scattering amplitude of the nu^th phonon mode induced by the momentum transfer mathbfq. The scattering amplitude is related to the nu^th phonon mode polarization vector vecxi_nu such that A_nu(mathbfq) = (vecqcdotvecxi_nu)^2omega_nu  for single-phonon scattering events.The Bose-Einstein distribution includes the thermal dependence such that n_nu(beta) = e^-betahbaromega_nu - 1^-1 with beta = (k_bT)^-1. The selection rules for scattering are enforced by,Delta_nu^pm(vecqveck) = delta(omega pm omega_nu)delta(mathbfq -mathbfk) where delta() denotes a Dirac delta. ","category":"page"},{"location":"refs/#Reference","page":"References","title":"Reference","text":"","category":"section"},{"location":"refs/#Contents","page":"References","title":"Contents","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#Index","page":"References","title":"Index","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Pages = [\"refs.md\"]","category":"page"},{"location":"refs/#Phunny.Phunny","page":"References","title":"Phunny.Phunny","text":"A semi-classical approach to solve for phonon frequencies and eigenmodes, built for integration with Sunny.jl. Extension of Sunny.jl to include phonon analysis.\n\n\n\n\n\n","category":"module"},{"location":"refs/#Phunny.U_from_phonons-Tuple{Model, Any}","page":"References","title":"Phunny.U_from_phonons","text":"U_from_phonons(model, Φ; T, cryst, qgrid=(12,12,12), q_cell=:primitive, eps_meV=1e-6)\n\nComputes the full anisotropic mean-square displacement tensors U^(s)_{αβ} (Å²) from the  phonon modes of phonons(model, Φ, q) at temperature T (K).\n\nEach mode ν at each q contributes\n\nΔU⁽ˢ⁾ = MSD_PREF_A2*coth(Eν/(2k_b T))*Re(e_{sν} e_{sν}†)/(MₛEν)\n\nsummed over q, ν and averaged over Nq points.\n\nSampling:\n\n- q-grid: centered uniform (Nx × Ny × Nz) r.l.u. grid\n- Acoustic (ν=1,2,3) Γ modes skipped for stability\n- Discard modes with `Eν ≤ eps_meV` (default 0.2 meV)\n\nNotes:\n\n- Eigenvectors are mass-weighted\n- U⁽ˢ⁾ is symmetrized `(U + Uᵀ)/2`\n- U⁽ˢ⁾ is averaged over `Nq`\n- Lacks symmetry weighting\n- Lacks LO-TO corrections\n\nUnits:\n\n- Energies in meV\n- Displacements in Å\n- Masses in amu\n- `MSD_PREF_A2` in units Å²⋅meV/amu\n\nReturns: \n\n`Vector{SMatrix{3,3,Float64,9}}`\n\none 3×3 matrix per atom.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.assemble_force_constants!-Tuple{Model}","page":"References","title":"Phunny.assemble_force_constants!","text":"assemble_force_constants!(model)\n\nBuilds real-space force constants Φ as a dictionary of 3×3 blocks keyed by (i,j,R), where (i,j) are basis-atoms indices and R is a lattice vector in fractional coordinates. This function does not mutate model.\n\nBond Stretching Block:  For each harmonic bond b with equilibrium vector r₀ = b.r0, longitudinal/tangential stiffness (k_L, k_T) = (b.kL, b.kT), and unit direction ̂e = r₀/‖r0‖; the force constant block is defined, K = kL*(êêᵀ) + kT*(I - êêᵀ), applied to the difference in displacements (uⱼ(R) - uᵢ(0)).\n\nBlocks are accumulated:\n\nΦ[(i,j,+R)] += -K_b;        Φ[(j,i,-R)] += -K_b\nΦ[(i,i,0)]  += +K_b;        Φ[(j,j,0)]  += +K_b\n\nensuring Newton's third law. \n\nTypes use StaticArrays: \n\n    keys → `Tuple{Int, Int, SVector{3,Int}}`\n    vals → `SMatrix{3,3,Float64,9}`\n\nOptional Bond-Angle (bending) Blocks: If β_bend > 0, additional 3-body contributions are added for triplets (i,j,k), where j is the angle vertex and neighbors (i,k) are selected from same-cell bonds (R==0).\n\nThe parameter bend_shell determines the bonding scheme:\n\n- `:nn`  selects nearest-neighbor bonds with distance ≤ `(1 + bend_tol)*r_min`\n- `:all` selects all neighbors\n\nelse, a simple \"second shell\" cut-off is assumed. \n\nFor each pair of neighbors rⱼᵢ, rⱼₖ with norms rᵢ and rₖ and directions ̂eᵢ and ̂eₖ, define two projectors Pᵢ = I - ̂eᵢ ̂eᵢᵀ and Pₖ = I - ̂eₖ ̂eₖᵀ.\n\nThen, the angular block matrices are defined:\n\nBᵢ  = Pᵢ / rᵢ²;             Bₖ = Pₖ / rₖ²\nRᵢₖ = (Pᵢ Pₖ)/(rᵢ rₖ);      Rₖᵢ = Rᵢₖᵀ\n\nwhere each bending contribution scales with β_bend and is accumulated into on-site and cross blocks among atoms i, j and k as:\n\nΦ[(i,i,0)] += β_bend*B_i\nΦ[(k,k,0)] += β_bend*B_k\nΦ[(j,j,0)] += β_bend*(B_i + B_k - R_ik - R_ki)\n\nΦ[(i,j,0)] += β_bend*(-B_i + R_ik);        Φ[(j,i,0)] += β_bend*(-B_i + R_ki)\nΦ[(j,k,0)] += β_bend*(-B_k + R_ki);        Φ[(k,j,0)] += β_bend*(-B_k + R_ik)\nΦ[(i,k,0)] += β_bend*(-R_ik);              Φ[(k,i,0)] += β_bend*(-R_ki)\n\nConservation laws are not enforced here and are enforced later by calling enforce_asr!(Φ,model).\n\nReturns\n\n- Φ::Dict{Tuple{Int,Int,SVector{3,Int}}, SMatrix{3,3,Float64,9}}\n\nNotes\n\n- Units: `k_L`, `k_T`, and `β_bend` must be consistent with displacements in length units.\n- Symmetry: both `(i,j,R)` and `(j,i,−R)` are filled for pair terms; bending uses `R=0`.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.bond_classes-Tuple{Any}","page":"References","title":"Phunny.bond_classes","text":"Return:\n\nclasses::Dict{BondClass,Vector{Int}} mapping each class to model.edge indices\nclist::Vector{BondClass} stable ordering of classes\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.build_model-Tuple{Any}","page":"References","title":"Phunny.build_model","text":"build_model(crystal; mass, neighbors_sunny=nothing, neighbors=nothing, cutoff=nothing, use_sunny_radius=true, kL=1.0, kT=1.0, supercell=(1,1,1))\n\nCreate a Model from a Sunny-like crystal object. Minimal interface expected:\n\nEither Sunny-style fields: crystal.latvecs (3×3), crystal.positions (fractional), crystal.types (Strings)\nor generic fields: crystal.lattice (3×3), crystal.positions (fractional), crystal.species (Symbols/Strings)\n\nBond assembly precedence:\n\nIf neighbors_sunny (e.g. Vector{Sunny.Bond}) is provided → fast path via Sunny geometry.\nElse if neighbors (list of tuples as documented in neighbor_bonds_from_sunny) is provided → fast tuple path.\nElse if use_sunny_radius && cutoff!=nothing && Sunny loaded → build via Sunny.all_bonds_for_atom.\nElse → fallback to portable cutoff scan neighbor_bonds_cutoff.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.dynamical_gradient!-Tuple{AbstractMatrix{ComplexF64}, AbstractMatrix{ComplexF64}, AbstractMatrix{ComplexF64}, Model, Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.dynamical_gradient!","text":"Fills pre-allocated dDx, dDy, dDz (3N×3N ComplexF64) with ∂D/∂q components. Arrays are overwritten; no allocation in the hot loop beyond scalars.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.dynamical_hessian!-Tuple{AbstractMatrix{ComplexF64}, Model, Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.dynamical_hessian!","text":"dynamical_hessian!(Hn, model, Φ, nhat; backend=:analytic, h=1e-2)\n\nFill Hn with the directional Hessian D^{(2)}{n̂} at Γ (INTERNAL units, same mass-weighted basis/units as `dynamicalmatrix`).\n\nBackends:\n\n:analytic     – exact in harmonic: one sweep over Φ with factor -(n·r)^2   :complexstep  – high-accuracy numeric using D(ih n) without API changes   :FiniteDiff   – central finite difference of ∂D/∂q along n   :AutoDiffHVP  – not implemented in this draft (placeholder)\n\nKeyword:\n\nh::Float64 = 1e-2  – step size \n\nfor :complexstep you can go much smaller\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.dynamical_matrix-Tuple{Model, Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.dynamical_matrix","text":"dynamical_matrix(model, Φ, q_cart)\n\nMass-weighted dynamical matrix D(q) from real-space Φ blocks. q_cart is Cartesian (Å⁻¹). Returns Hermitian matrix.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.enforce_asr!-Tuple{Dict{Tuple{Int64, Int64, StaticArraysCore.SVector{3, Int64}}, StaticArraysCore.SMatrix{3, 3, Float64, 9}}, Int64}","page":"References","title":"Phunny.enforce_asr!","text":"enforce_asr!(Φ, N)\n\nAcoustic sum rule: for each atom i, ∑{j,R} Φ{i j}(R) = 0. Adjust on-site blocks to satisfy translational invariance.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.fit_per_pair!-Tuple{Any, Any}","page":"References","title":"Phunny.fit_per_pair!","text":"Fit per-class (kL,kT) to supplied targets. If no targets are given, this returns seeded values. Regularization λ discourages extreme k ratios.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.msd_from_phonons-Tuple{Model, Any}","page":"References","title":"Phunny.msd_from_phonons","text":"msd_from_phonons(model, Φ; T, cryst, qgrid=(12,12,12), q_cell=:primitive, eps_meV=1e-6)\n\nComputes the mean-square displacements ⟨us^2⟩(T) per-site in Å² directly from the phonon spectrum: ⟨us^2⟩ = (1/Nq) * Σ{q,ν} (ħ² / (2 Ms EJ)) * coth(EJ / (2 kB T)) * Σα |ephys(s,α;q,ν)|² where EJ = EmeV ⋅ meVtoJ and ephys are physical (non mass-weighted) polarization vectors. Modes with E ≤ eps_meV are skipped (Γ handling); Convergence may require refinement of qgrid.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_cutoff-Tuple{StaticArraysCore.SMatrix{3, 3, Float64, 9}, Vector{StaticArraysCore.SVector{3, Float64}}}","page":"References","title":"Phunny.neighbor_bonds_cutoff","text":"neighbor_bonds_cutoff(lattice, fracpos; cutoff, kL, kT, supercell=(1,1,1))\n\nConstruct bonds using a radial cutoff by scanning a small supercell (portable path). kL and kT can be numbers or functions (i,j,rij)->stiffness for non-uniform springs. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_from_sunny-Tuple{Any, Any}","page":"References","title":"Phunny.neighbor_bonds_from_sunny","text":"neighbor_bonds_from_sunny(cryst, bonds; kL=1.0, kT=1.0)\n\nFast-path bond construction using Sunny's bonds and geometry. bonds may be a Vector of:\n\nSunny.Bond         (fields: i,j,n)\nTuples (i,j,n::SVector{3,Int})\nTuples (i,j,Δ::SVector{3,Float64})  # direct Cartesian Δ\n\nkL/kT can be numbers or (i,j,r0)->value. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.neighbor_bonds_radius-Tuple{Any}","page":"References","title":"Phunny.neighbor_bonds_radius","text":"neighbor_bonds_radius(cryst; cutoff, kL, kT)\n\nSunny-powered radius query: builds bonds using Sunny.all_bonds_for_atom. Requires using Sunny. Returns Vector{Bond}.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.onephonon_dsf-Tuple{Model, Any, StaticArraysCore.SVector{3, Float64}, AbstractVector{<:Real}}","page":"References","title":"Phunny.onephonon_dsf","text":"onephonon_dsf(model, Φ, q, Evals; T=300.0, bcoh=nothing, η=0.5, mass_unit=:amu, q_basis=:cart, q_cell=:primitive, cryst=nothing)\n\nComputes one-phonon coherent S(q,E) on energy grid Evals (meV).\n\nDebye–Waller is intrinsic: full anisotropic tensors U_s(T) are computed from the phonon spectrum.\nbcoh optional Vector of coherent scattering lengths (length N)\nη Gaussian HWHM for energy broadening (meV)\nmass_unit :amu or :kg (Model.mass is assumed to be :amu typically)\nq_basis/q_cell/cryst follow phonons conventions\n\nReturns S(E) (arbitrary but consistent units).\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.onephonon_dsf_4d-Tuple{Model, Any, Vararg{AbstractVector, 4}}","page":"References","title":"Phunny.onephonon_dsf_4d","text":"onephonon_dsf_4d(model, Φ, q1, q2, q3, Evals;\n                 q_basis=:rlu, q_cell=:primitive, cryst=nothing,\n                 T=300.0, η=0.5, mass_unit=:amu, bcoh=nothing,\n                 threads=true)\n\nCompute the one-phonon coherent dynamic structure factor on a 4D grid:\n\nq1, q2, q3 are 1D axes defining a rectilinear grid in q-space.\nIf q_basis=:rlu, they are fractional coordinates along the three reciprocal basis vectors.\nIf q_basis=:cart, they are Cartesian components (Å⁻¹).\nEvals is the 1D energy axis (meV). Result has shape (length(q1), length(q2), length(q3), length(Evals)).\n\nThis routine is thread-parallel over the q-grid to mitigate the O(N^3) complexity.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.phonons-Tuple{Model, Any, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.phonons","text":"phonons(model, Φ, q; q_basis=:cart, q_cell=:primitive, cryst=nothing)\n\nDiagonalizes the mass-weighted dynamic matrix D(q). Returns (eigvals, eigvecs) with energies in meV and a 3N×3N  block matrix with columns defined by the eigenvectors (phonon polarization vectors).\n\nThe wavevector q may be in Cartesian Å⁻¹ (q_basis=:cart) or relative lattice untis (R.L.U.) (q_basis=:rlu with q_cell=:primitive or :conventional).\n\nIf passing RLU, also pass the underlying crystal cryst via keyword.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.q_cartesian-Tuple{Any, StaticArraysCore.SVector{3, Float64}}","page":"References","title":"Phunny.q_cartesian","text":"q_cartesian(cryst, q; basis=:cart, cell=:primitive)\n\nConvert a wavevector to Cartesian (Å⁻¹). q may be:\n\nbasis=:cart    → already Cartesian (Å⁻¹)\nbasis=:rlu     → reduced lattice units (h,k,l). cell chooses :primitive or :conventional.\n\nUses Sunny.prim_recipvecs(cryst) if Sunny is loaded and cell=:primitive, otherwise falls back to 2π * inv(L)' where L is the corresponding direct lattice.\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.seed_params-Tuple{Any, Any, Any}","page":"References","title":"Phunny.seed_params","text":"Seed (kL,kT) per bond class using geometry:  kL ∝ 1/r^3 with species-dependent prefactor; kT = γkL with γ by orient. Returns Vector θ of length 2nc storing log-parameters to enforce positivity: k = exp(θ).\n\n\n\n\n\n","category":"method"},{"location":"refs/#Phunny.update_fcm!-NTuple{4, Any}","page":"References","title":"Phunny.update_fcm!","text":"Write kL,kT from θ into all edges of each class, then assemble FCMs. Calls enforce_asr! to satisfy translational invariance.\n\n\n\n\n\n","category":"method"}]
}
